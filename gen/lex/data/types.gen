
{
    types {
        Root {
            Instruction {
                InstrName {
                    Adc Add And Bit Call Ccf Cp Cpl Daa Dec
                    Di Ei Halt Inc Jp Jr Ld Ldh Ldi Ldd Ldhl 
                    Or Pop Push Res Ret Rl Rla Rlc Rld Rr Rra 
                    Rrc Rrca Rrd Rst Sbc Scf Set Sla Sll Sra 
                    Srl Stop Sub Swap Xor Reti Rlca Nop
                }

                Argument {
                    Register { A B C D E H L Af Bc De Hl Sp }

                    Lit { LitBin LitHex LitDec LitStr }

                    At { At0 At1 }

                    Flag { FlagZ FlagNz FlagC FlagNc }

                    Expr {
                        BinAdd BinSub BinMul BinDiv BinMod BinShr 
                        BinShl BinAnd BinOr BinXor UnNot UnNeg 
                    }

                    Identifier
                }
            }

            Directive {
                DefB
                DefW
                DefS
                Include

                Macro { MacroIdent MacroArg MacroBody }
            }

            Marker { NamedMark AnonMark Label }

            Repeat
            MacroCall
        }
    }

    // Those are identified by their name lowercased.
    are_words { ..InstrName ..Register }

    // Those are identified by the contained word.
    word_pairs {
        FlagZ { Z }
        FlagNz { NZ }
        FlagC { C }
        FlagNc { NC }
        BinMod { mod }
        BinAnd { and }
        BinOr { or }
        BinXor { xor }
        UnNot { not }
    }

    // UnNeg would conflict with BinSub.
    // BinMod and BinAnd would conflict with literals.
    char_words {
        At0 { ( }
        At1 { ) }
        BinMul { * }
        BinDiv { / }
        BinAdd { + }
        BinShl { < }
        BinShr { > }
    }

    prefixes {
        & // LitHex AnonMark NamedMark
        # // ..Directive
        % // LitBin
        " // LitStr
        . // MacroArg
        : // Label
    }

    // These types can hold a value.
    has_value { 
        NamedMark MacroArg Label Repeat MacroIdent Identifier
        ..Lit
    }

    // These tokens are closed on a newline.
    ends_on_newline { 
        Instruction Argument MacroCall Directive Marker 
        ..Directive ..Marker 
    }

}
