
{
    types {
        Root {
            Instruction {
                InstrName {
                    Adc Add And Bit Call Ccf Cp Cpl Daa Dec
                    Di Ei Halt Inc Jp Jr Ld Ldh Ldi Ldd Ldhl 
                    Or Pop Push Res Ret Rl Rla Rlc Rld Rr Rra 
                    Rrc Rrca Rrd Rst Sbc Scf Set Sla Sll Sra 
                    Srl Stop Sub Swap Xor Reti Rlca Nop
                }

                Argument {
                    Register { A B C D E H L Af Bc De Hl Sp }

                    Lit { LitBin LitHex LitDec LitStr }

                    At { At0 At1 }

                    Flag { FlagZ FlagNz FlagC FlagNc }

                    Expr {
                        BinAdd BinSub BinMul BinDiv BinMod BinShr 
                        BinShl BinAnd BinOr BinXor UnNot UnNeg 
                    }

                    Identifier
                }
            }

            Directive {
                DefB DefW DefS
                Include
                Macro { MacroIdent MacroArg MacroBody }
            }

            Marker { NamedMark AnonMark Label }

            Repeat
            MacroCall
        }
    }

    // Those do not require validation rules.
    ignored { Root ..At }

    // For those, validity rules follow the hierarchy defined in types
    validate_from_hierarchy {
        Instruction 
        Directive ..Directive
        InstrName ..InstrName 
        Argument 
        Register ..Register 
        Flag ..Flag 
        ..Lit Lit 
        Lit { Expr At ..Expr Argument } //Also in Repeat? TODO check 
        Identifier { DefB DefW DefS } //MacroIdent? TODO 
        Marker ..Marker
        MacroCall //TODO only if no nesting, check that.
    }

    // `Children` `ValidParents`
    // e.g.     Expr is valid inside DefB or DefW
    validation {
        Expr { DefB DefW }
        { ..Expr At } { Expr At ..Expr } 
        Instruction MacroCall
        //TODO { Macro { MacroIdent MacroArg MacroBody } Repeat }
    }

    // Those are identified by their name lowercased.
    are_words { ..InstrName ..Register }

    // Those are identified by the contained word.
    word_pairs {
        FlagZ { Z }
        FlagNz { NZ }
        FlagC { C }
        FlagNc { NC }
        BinMod { MOD }
        BinAnd { AND }
        BinOr { OR }
        BinXor { XOR }
        UnNot { NOT }
        BinShl { SHL }
        BinShr { SHR }
    }

    char_words {
        At0 { ( }
        At1 { ) }
        BinMul { * }
        BinDiv { / }
        BinAdd { + }
        BinSub { - }
    }

    prefixes {
        & // LitHex AnonMark NamedMark
        # // ..Directive
        % // LitBin
        " // LitStr
        . // MacroArg
        : // Label
    }

    // These types can hold a value.
    has_value { 
        NamedMark MacroArg Label Repeat MacroIdent Identifier
        ..Lit
    }

    // These tokens are closed on a newline.
    ends_on_newline { 
        Instruction Argument MacroCall Directive Marker Expr
        ..Directive ..Marker 
    }

}
